---
icon: /assets/icon/linux.svg
category:
  - 运维基础
contributors: true
lastUpdated: true
pageview: true
isOriginal: true
date: 2025-12-16
---


# 08-任务与进程

Linux是一种多用户操作系统，也是一种多任务系统，进程是正在运行的实例程序，常见的有Windows下的任务管理器，在Linux中常使用top、ps、pstree等工具来查看进程的状态。

每一个进程都有自己的ID，例如Pid和Uid、Fid。

> 注意：用来显示进程相关信息的命令主要从/porc文件系统中存储的原始数据获取信息。每一个进程都在/porc的子目录存储了自己的信息，并且是以进程ID的方式。

## 查看进程

`ps`命令是"process status"的缩写，ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。

```shell
语法：
ps [选项]
    -a：显示所有进程，包括其他用户的进程。
    -d：显示磁盘使用情况。
    -e：显示所有进程，与-a 选项相同。
    -f：显示更多的字段信息。
    -l：显示更多的字段信息，与-f 选项类似，但-l 选项会显示进程的完整路径。
    -p：显示进程的 PPID（父进程 ID）。
    -r：显示当前系统的运行级别。
    -u：显示用户信息。
    -v：显示版本信息。
    -x：显示被中断的进程。
```

使用`ps -A`查看所有的进程

![image-20251210095415674](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210095415674.png)

使用`ps -aux`选项可以显示用户和被中断的进程

![image-20251210095151787](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210095151787.png)

使用`ps -le`查看所有进程的同时查看PID和进程的优先级。

![image-20251210095658462](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210095658462.png)

之查看Shell产生的进程可以使用`ps -l`

```shell
miui@Fedora:~$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    1378    1377  0  80   0 -  2108 do_wai pts/0    00:00:00 bash
0 R  1000    1564    1378 99  80   0 -  2562 -      pts/0    00:00:00 ps
```

ps命令输出信息的含义

| 参数    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 该进程是由哪一个用户产生的                                   |
| PID     | 进程的PID                                                    |
| %CPU    | 进程占用CPU资源的百分比                                      |
| %MEM    | 进程占用内存资源的百分比                                     |
| VSZ     | 该进程占用虚拟内存的大小                                     |
| RSS     | 进程占用的实际物理内存大小                                   |
| TTY     | 进程是在哪一个终端运行的<br/>其中，tty1～tty6 代表本地控制台终端（可以通过 Alt+F1～F6 快捷键切换不同的终端），tty2～tty6 是本地的字符界面终端，<br/>tty1 是图形终端。pts/0～ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，<br/>第二个远程连接占用 pts/1，依次增长。 |
| STAT    | 进程的状态                                                   |
| START   | -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。<br/>-R：该进程正在运行。<br/>-S：该进程处于睡眠状态，可被唤醒。<br/>-T：停止状态，可能是在后台暂停或进程处于出错状态。<br/>-W：内存交互状态（从 2.6内核开始无效）。<br/>-X：死掉的进程（应该不会出现）。<br/>-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。<br/>-<：高优先级（以下状态在 BSD 格式中出现）。<br/>-N：低优先级。<br/>-L：被锁入内存。<br/>-S：包含子进程。<br/>-l:多线程（小写 L）。<br/>-+：位于后台。该进程的启动时间 |
| TIME    | 该进程占用CPU的运算时间，这不是系统时间                      |
| COMMAND | 产生此进程的命令                                             |

在使用`ps -l`命令的时候，返回的参数解析如下：

| 参数  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| F     | Flags，是产生进程的标志<br/>0：代表无标志<br/>1：是Fork但是没有exec<br/>4：使用进程root权限<br/>40：多线程进程 |
| S     | 进程的状态<br/>R：Running准备就绪<br/>S：Slepping可终端睡眠<br/>D：不可中断睡眠<br/>T：停止<br/>Z：僵尸进程<br/> |
| C     | CPU的使用率                                                  |
| PRI   | 动态优先级，数字越小，优先级越高<br/>实时进程0-99<br/>普通进程100-139 |
| NI    | 静态优先级，用户可以调整的，默认是0，范围是-20(最高优先级)~-19(最低优先级) |
| ADDR  | 内存地址                                                     |
| SZ    | 虚拟内存大小                                                 |
| WCHAH | 进程睡眠的原因<br/>hirimer_nanosleep：睡眠计时器<br/>do_select：I/O多路复用<br/>wait_for_completoin：等待某个内核事件完成<br/>futex_wait_queue_me：等待futex<br/>finissh_task_switch：切换上下文 |

## 进程树

`pstree` 命令的英文全称是"process tree"，即将所有进程以树状图显示，树状图将会以 pid(如果有指定)或是以 systemd 这个基本进程为根(root)，如果有指定使用者 id，则树状图会只显示该使用者 所拥有的进程。

```shell
语法：
pstree [选项]
pstree [-acglpsStTuZ] [ -h | -H 进程号 ] [ -n | -N 类型 ]
-G |-U ］ 【进程号I 用户 ］或：pstree

  -a, --arguments     显示命令行参数
  -A, --ascii         使用 ASCII 行绘制字符
  -c, --compact-not   不要对完全相同的子树进行压缩
  -C, --color=类型    按照指定属性对进程上色
                      (age)
  -g, --show-pgids    显示进程组 ID；隐含启用 -c 选项
  -G, --vt100         使用 VT100 行绘制字符
  -h, --highlight-all 高亮显示当前进程和其所有祖先
  -H PID, --highlight-pid=PID
                      高亮显示指定 PID 对应的进程和其所有祖先
  -l, --long          不要截断长行
  -n, --numeric-sort  按照 PID 对输出进行排序
  -N 类型, --ns-sort=类型
                      按照指定命名空间类型对输出进行排序
                              (cgroup, ipc, mnt, net, pid, time, user, uts)
  -p, --show-pids     显示 PID；隐含启用 -c 选项
  -s, --show-parents  显示所选进程的父进程
  -S, --ns-changes    显示命名空间的变化
  -t, --thread-names  显示完整线程名称
  -T, --hide-threads  隐藏线程，只显示进程
  -u, --uid-changes   显示用户 ID（UID）的变化
  -U, --unicode       使用 UTF-8（Unicode）的行绘制字符
  -V, --version       显示版本信息
  -Z, --security-context
                      显示安全属性

  进程号 从指定进程号开始；默认为 1（init）
  用户   仅显示从指定用户的进程开始的进程树
```

实例：

显示当前所有进程的进程号和进程ID

```shell
miui@Fedora:~$ pstree -p
systemd(1)─┬─NetworkManager(935)─┬─{NetworkManager}(971)
           │                     ├─{NetworkManager}(973)
           │                     └─{NetworkManager}(974)
           ├─VGAuthService(949)
           ├─abrt-dump-journ(989)
           ├─abrt-dump-journ(991)
           ├─abrt-dump-journ(993)
           ├─abrtd(962)─┬─{abrtd}(977)
           │            ├─{abrtd}(978)
           │            └─{abrtd}(980)
           ├─anacron(1582)
           ├─atd(1062)
           ├─auditd(892)─┬─sedispatch(894)
           │             ├─{auditd}(893)
           │             └─{auditd}(895)
           ├─chronyd(955)
           ├─crond(1067)
           ├─dbus-broker-lau(933)───dbus-broker(934)
           ├─dockerd(1054)─┬─containerd(1144)─┬─{containerd}(1145)
           │               │                  ├─{containerd}(1146)
           │               │                  ├─{containerd}(1147)
           │               │                  ├─{containerd}(1148)
           │               │                  ├─{containerd}(1149)
           │               │                  ├─{containerd}(1150)
           │               │                  └─{containerd}(1151)
           │               ├─{dockerd}(1122)
           │               ├─{dockerd}(1123)
           │               ├─{dockerd}(1124)
           │               ├─{dockerd}(1125)
           │               ├─{dockerd}(1126)
           │               ├─{dockerd}(1143)
           │               ├─{dockerd}(1153)
           │               ├─{dockerd}(1154)
           │               └─{dockerd}(1155)
           ├─gssproxy(1037)─┬─{gssproxy}(1039)
           │                ├─{gssproxy}(1040)
           │                ├─{gssproxy}(1041)
           │                ├─{gssproxy}(1042)
           │                └─{gssproxy}(1043)
           ├─irqbalance(940)───{irqbalance}(970)
           ├─login(1090)───bash(1344)
           ├─rsyslogd(943)─┬─{rsyslogd}(952)
           │               └─{rsyslogd}(975)
           ├─sshd(1030)─┬─sshd(1373)───sshd(1377)───bash(1378)───pstree(1681)
           │            ├─sshd(1424)───sshd(1428)───bash(1429)
           │            └─sshd(1454)───sshd(1458)───sftp-server(1459)
           ├─systemd(1326)───(sd-pam)(1328)
           ├─systemd-homed(947)
           ├─systemd-journal(788)
           ├─systemd-logind(948)
           ├─systemd-oomd(889)
           ├─systemd-resolve(890)
           ├─systemd-udevd(824)
           ├─systemd-userdbd(891)─┬─systemd-userwor(1678)
           │                      ├─systemd-userwor(1679)
           │                      └─systemd-userwor(1680)
           └─vmtoolsd(950)─┬─{vmtoolsd}(960)
                           ├─{vmtoolsd}(985)
                           └─{vmtoolsd}(986)
```

## 动态进程

`top`命令是动态查看进程变化，监控 Linux 的系统状况；它是常用的性能分析工具，能够实时显示系统资源各个进程占用状况，类是 windows 的任务管理器。

```shell
语法：
top [选项]
    -b：以批处理模式操作;
    -c：显示完整的治命令;
    -d：屏幕刷新间隔时间;
    -I：忽略失效过程;
    -s：保密模式;
    -S：累积模式;
    -i<时间>：设置间隔时间;
    -u<用户名>：指定用户名;
    -p<进程号>：指定进程;
    -n<次数>：循环显示的次数
```

大多数情况下都是使用交互命令，很少使用选项，除非特殊情况。

### 交互命令

在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项，其中一些命令可能会被屏蔽。

```shell
h：显示帮助画面，给出一些简短的命令总结说明
k：终止一个进程
i：忽略闲置和僵死进程，这是一个开关式命令
q：退出程序
r:重新安排一个进程的优先级别
S：切换到累计模式
s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入值则系统将不断刷新，默认值是5s
f或者F：从当前显示中添加或者删除项目
o或者0：改变显示项目的顺序
l：切换显示平均负载和启动时间信息
m：切换显示内存信息
t：切换显示进程和CPU状态信息
c：切换显示命令名称和完整命令行
M：根据驻留内存大小进行排序
P：根据CPU使用百分比大小进行排序
T：根据时间/累计时间进行排序
W：将当前设置写入~/.toprc文件中
```

实例：

动态的查看当前进程状况，使用top命令即可进入交互界面

![image-20251210115150578](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210115150578.png)

在如图界面我们可以通过一些字符进行交互，例如杀死进程的操作如下：

![image-20251210115543717](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210115543717.png)

使用`q`键即可退出当前操作，或者退出当前动态进程。

top进程字段说明：

| 字段  | 解析                                                         |
| ----- | ------------------------------------------------------------ |
| PID   | 进程的ID，唯一的标识符                                       |
| USER  | 进程的实际用户                                               |
| PR    | 进程调度的优先级，这个字段的值是“rt”。则表示这些进程运行在实时态 |
| NI    | 进程的优先级，nice值，越小优先级越高                         |
| VIRT  | 进程使用的虚拟内存                                           |
| RES   | 驻留内存的大小，驻留内存是任务使用的非交换物理内存大小       |
| SHR   | 进程使用的共享内存                                           |
| S     | 这个是进程的状态。它有以下不同的值:D 不可中断的睡眠态。<br/>R 运行态<br/>S 睡眠态<br/>T 被跟踪或已停止<br/>Z 僵尸进程 |
| TIME+ | 任务启动后到现在所用的全部时间，精确到秒                     |

也可以使用第三方的进程管理工具，例如Htop、Btop、Atop等等。

这里给大家看看Htop与Btop的进程模样，Htop进程面板如下：

![image-20251210121533650](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210121533650.png)

Btop进程面板如下：

![image-20251210121754423](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251210121754423.png)

> 安装Htop和Btop的命令如下：
>
> ```shell
> sudo dnf install 0y htop btop
> ```

## 终止进程

`kill`和本意一样，杀死，也就是杀死进程，终止进程。kill命令默认使用信号为 15，用于结束进程或工作。如果进程或工作忽略此信号，则可以使用信号 9，强制杀死进程。

```shell
语法：
kill [选项] [进程号]
kill［-s 信号声明 丨-n 信号编号丨-信号声明］ 进程号I 任务声明 ··．或 kill-l［信号声明］
    -a：当处理当前进程时，不限制命令名和进程号的对应关系
    -l：<信息编号>：若不加<信息编号>选项，则-l参数会列出全部的信息名称
    -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号
    -s：<信息名称或编号>：指定要送出的信息
    -u：指定用户
```

`killall`命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。杀死一组同名的进程我们也可以使用 kill 命令来一个个实现，只不过需要在使用 ps 命令查询进程号时配合 grep 命令查找出对应进程名的所有 PID。

```shell
语法：
killall [选项]
    -e：对长名称进行精确匹配;
    -l：忽略大小写的不同;
    -p：杀死进程所属的进程组;
    -i：交互式杀死进程，杀死进程前需要进行确认；
    -l：打印所有已知信号列表;
    -q：如果没有进程被杀死。则不输出任何信息;
    -r：使用正规表达式匹配要杀死的进程名称;
    -S：用指定的进程号代替默认信号“SIGTERM";
    -u：杀死指定用户的进程
```

## 进程优先级

### nice

`nice`命令是用来调整进程的执行优先级的，nice 命令表示新执行的命令即给予新的优先级值。进程优先级的值越小优先级越高。nice常用来合理分配系统资源。

```
语法：
nice [选项] [命令 [参数]...]
从 -20（最高优先级）到 19（最低优先级）。
  -n, --adjustment=N   在优先级数值上加上整数 N（默认为 10）
      --help        显示此帮助信息并退出
      --version     显示版本信息并退出
```

> [!CAUTION]
>
> 以指定的优先级 (niceness) 运行 <命令>，这会影响相应进程的调度。
> 如果不指定 <命令>，程序会显示当前的优先级。优先级的范围是
>
> 退出状态：
>   125  如果 nice 命令本身执行失败
>   126  如果找到了 <命令>，但无法执行
>   127  如果未找到 <命令>
>
> 其他情况下，退出状态是 <命令> 的退出状态

在程序中，程序运行一般存在前台和后台两种程序，大多数我们看不见的程序都是处于后台运行的，可以实现交互运行的程序都是前台，前台会占用我们的交互。

这里我们使用后台来进行运行，前后台的概念会在后面进行详细的讲解。设置程序的优先级操作如下：

![image-20251215160139681](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215160139681.png)

使用`-n`来设置优先级，我们在使用vim之后，在后面添加了一个&符号，这使得我们创建了一个后台进程，如果是前台进程，就会进入到Vim编辑器中。如果需要将正在运行的前台命令放到后台，并且暂停，可以使用`Ctrl+Z`完成。可以看见我们创建了六次进程：

![image-20251215160529977](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215160529977.png)

使用kill来杀死所有的vim后台进程，操作如下：

![image-20251215161611078](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215161611078.png)

### renice

`renice`命令是与 nice 关联的一个命令，由 re 两个字母就知道可以重新调整进程执行的优先级，可以指定群组或者用户名调整优先级等级，并修改隶属于该群组或者用户的所有程序优先级。等级范围为[-20,19]。同样仅系统管理员可以拉高优先级。nice 在进程拉起时调整，renice 在进程执行时调整。

```shell
语法：
renice [选项] 
    -n <num>               指定“nice值”  
                              如果在环境中设置了POSIXLY_CORRECT标志，  
                              则该优先级是“相对”于当前进程的优先级；  
                              否则，该优先级是“绝对”的。  
    --priority <num>       指定“绝对”的“nice值”  
    --relative <num>       指定“相对”的“nice值”  
    -p, --pid              将参数解释为进程ID（默认值）  
    -g, --pgrp             将参数解释为进程组ID  
    -u, --user             将参数解释为用户名或用户ID  

    -h, --help             显示此帮助信息  
    -V, --version          显示版本信息
```

我们再次创建几个vim后台进程，然后来调整进程的优先级：

![image-20251215162221121](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215162221121.png)

将进程1504的优先级调整为-5，操作如下：

![image-20251215162531260](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215162531260.png)

前面有一个错误，使用`-n`的时候-20写成了20，因为区间是-20到19，超了之后我们可以看到，他的进程优先级还是19，并不是20。如图：

![image-20251215162920185](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215162920185.png)

## 任务列表

`jobs`命令主要用于显示系统中的任务列表及其运行状态，该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应一个或者多个进程号。

```shell
语法：
jobs [选项] [任务、命令]
      -l        在正常信息的基础上列出进程 ID
      -n        仅列出上次通知之后改变了状态的进程
      -p        仅列出进程 ID
      -r        限制仅输出运行中的任务
      -s        限制仅输出已停止的任务
```

我们可以使用jobs来查看任务列表，如图：

![image-20251215163337311](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215163337311.png)

目前我们的任务主要就是四个后台vim，使用`-l`选项可以显示更详细的进程ID

![image-20251215163434538](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215163434538.png)

使用`-s`查看停止的进程:

![image-20251215163604669](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215163604669.png)

因为我们在创建vim后台的时候，就已经提示过已停止，程序在后台是停止的，他们只是存在一个运行的任务，并没有启用。这是非常需要注意的，为什么放在这里讲，因为马上就讲解前后台的内容了。

## 前台与后台

### 后台

`bg`命令用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号&的效果是相同的，都是将其放到系统后台执行。

```shell
语法：
bg [任务号]
```

**bg与&的区别：**

| 特性     | bg                                                           | &                                                  |
| -------- | ------------------------------------------------------------ | -------------------------------------------------- |
| 使用情况 | 再启动命令的时候加上，可以直接让程序在后台运行               | 在程序已经启动被暂停后，用它恢复到后台             |
| 运行情况 | 启动的时候就脱离了前台控制，属于终端的子进程                 | 原本是前台进程，暂停后放在后台，依旧是终端的子进程 |
| 输入输出 | 默认继承当前终端的stdin、stdout、stderr，有可能会在终端打印输出 | 同样继承了终端输出，可能会在终端进行打印           |

> [!IMPORTANT]
>
> 在前面我们说的vim，创建的vim进程是停止的，这个原因其实是vim自身的特性，因为没有在前台使用，在后台的时候就会自动进入暂停断开的状态，因为vim是一个交互工具，在后台是无法交互的，驻留后台会占用内存，所以在后台的时候会暂停。

我们使用其他的命令配合&符号，依然可以创建一个后台运行的进程。

我们可以使用如下命令来查看vim后台的状态码：

![image-20251215165038223](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215165038223.png)

返回的状态是T，T表示进程信号被暂停。

我们接下来演示一下bg的使用，从前台到后台的操作。

![PixPin_2025-12-15_16-53-39](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/PixPin_2025-12-15_16-53-39.gif)

现在任务处于后台，我们怎么吧后台的进程重新加入前台呢？

### 前台

`fg`命令用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。与 bg 命令一样，若后台任务中只有一个，则使用该命令时，可以省略任务号。

```shell
语法：
fg [任务号]
```

我们刚才把`ping bing.com`放到了后台，现在可以将其放到前台来操作，操作如下：

<video src="./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/PixPin_2025-12-15_17-01-20.mp4"></video>

使用fg的时候我们通过jobs可以看到任务前面有个编号2和3，我们使用`%`加上这个数字就能指定回到哪一个前台进程，使用`&`创建的后台进程都是可以返回的。

### 后台任务脱离终端

`nohup`命令可以让后台的任务脱离终端。

```shell
语法：
nohup 命令 [参数] [&]
```

- 命令：要执行的程序 / 脚本（如 python app.py、./start.sh）；
- &：可选，将进程放入后台运行（不加 & 则进程仍在前台，终端被占用，仅退出终端时不终止）；
- 组合使用 nohup ... & 是最常用的方式（后台运行 + 不挂断）。

例如启动一个后台进程：

```shell
nohup java -jar app.jar > app.log 2>&1 &
# 查找指定进程（如 java 进程）
ps -ef | grep java

# 查看当前终端的后台任务（带编号）
jobs -l
```

如果不需要保存输出，可将输出重定向到 `/dev/null`（空设备，相当于 “黑洞”）：

```shell
nohup ./script.sh > /dev/null 2>&1 &
```

后台运行 Python 服务

```bash
# 启动 Flask 服务，日志追加到 flask.log
nohup python -m flask run --host=0.0.0.0 >> flask.log 2>&1 &
```

后台运行 Shell 脚本

```bash
# 给脚本执行权限（首次运行）
chmod +x backup.sh
# 后台执行备份脚本，输出写入 backup.log
nohup ./backup.sh >> backup.log 2>&1 &
```

远程 SSH 执行后台任务（避免断开终止）

```bash
# 远程执行脚本，且退出 SSH 后仍运行
ssh user@remote-ip "nohup ./remote_script.sh >> remote.log 2>&1 &"
```

## 服务进程

### systemd

要想了解 systemd是做什么的，我们需要首先了解Linux的启动过程。如图 所示：

![image-20251215171911017](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215171911017.png)

第一阶段是硬件启动阶段，UEFI 或BIOS 初始化，运行 POST 开机自检选择启动设备；第二阶段是 GRUB 引导阶段，它是一个多重操作系统启动管理器，用来引导不同系统，Linux使用的是 GRUB2；第三阶段是内核引导阶段，这一阶段涉及驱动加载、切换到真正的根文件系统以及内核初始化；第四阶段是系统初始化阶段，在这一阶段启动 systemd 进程。

`systemd`可以管理所有系统资源，不同资源统称为 unit，unit 由其相关配置文件进行标识、识别和配置；文件中主要包含了系统服务、监听的 socket、保存的快照以及其他与init 相关的信息。

在 Linux 系统中，Unit 是 systemd 管理下的可执行文件，用于启动、停止、重启和检查服务状态。Unit 文件分为以下几个类型:

- 服务（Service）：这是最常见的Unit 类型，用于管理一个或多个相关服务。服务可以是应用程序、后台进程或其他运行时组件。每个服务都可以独立启动、停止和重启。
- 目标（Target）：目标是一个或多个服务的集合，它们按照特定的依赖关系组织在一起。当一个目标被启动时，其依赖的服务也会被自动启动。
- 设备（Device）：设备Unit 用于管理硬件设备，例如磁盘分区、网络接口等。当设备被挂载或卸载时，相应的设备 Unit 会被触发。
- 路径（Path）：路径 Unit 用于管理文件和目录。当文件或目录被创建、删除或修改时，相应的路径 Unit 会被触发。
- 文件（File）：文件Unit 用于管理单个文件。当文件被创建、删除或修改时，相应的文件5 Unit 会被触发。
- 时间（Time）：时间 Unit 用于在特定的时间执行某个操作，例如定时启动或停止服务。
- 范围（Scope）：范围Unit 用于定义一组服务的生命周期行为，例如在某个服务启动前执行其他服务。

Unit 文件可以存储在 /etc/systemd/unit/ 目录下，也可以分布在各个服务特定的目录中。Unit 文件的扩展名通常为.service。通过 systemctl 命令，系统管理员可以查询、启动、停止、重启和管理Unit。

| 运行级别 | systemd target           | 说明                                                         |
| -------- | ------------------------ | ------------------------------------------------------------ |
| 0        | 未设置(关闭系统)         | 关闭系统，此级别不能设置为默认，否则无法正常启动             |
| 1        | 单用户(syslog)           | 提供基本的系统日志功能，单用户模式，具有 root 权限           |
| 2        | 无网络多用户             | 多用户模式，但没有网络支持                                   |
| 3        | 有网络多用户             | 多用户模式，具有网络支持，常用的运行级别                     |
| 4        | 保留                     | 保留的运行级别，一般不使用                                   |
| 5        | 有网络和图形化多用户模式 | 具有网络和图形界面的多用户模式，如笔记本电脑电池用尽时可能会切换到此模式 |
| 6        | 重启                     | 系统将重启，此级别不能设置为默认，否则电脑将一直开机重启     |

> [!CAUTION]
>
> 注意：运行级别 0-5 是由 init 进程控制的，而 systemd 的目标（target） 是另外一种服务管理方式。在实际使用中，运行级别与 systemd 的目标可以相互映射。例如，运行级别 3 可以对应到一个具有网络支持的多用户模式的 systemd target。 具体的映射关系取决于系统配置和需求。

### systemctl

`systemd`是 Linux 系统的初始化系统和服务管理器，是一套后台运行的系统程序。
`systemctl`是管理 systemd 的命令行工具，是用户和 systemd 交互的入口。

```shell
语法：
systemctl [选项] [命令] ...
```

详细说一下区别：

| 特性         | **systemd**                                                  | **systemctl**                                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**     | 系统级的初始化和服务管理守护进程                             | 操作 `systemd` 的命令行客户端工具                            |
| **作用**     | 1. 启动系统、管理开机流程2. 监控和管理所有系统服务（如 sshd、nginx）3. 处理服务依赖、日志、挂载等系统任务 | 1. 查看服务状态2. 启动 / 停止 / 重启服务3. 设置服务开机自启4. 管理系统运行级别（target） |
| **运行方式** | 作为系统 PID 为 1 的进程，开机即启动，后台持续运行           | 由用户在终端手动执行，执行完即退出                           |
| **使用场景** | 底层自动运行，用户无需直接操作                               | 用户日常管理服务的工具，比如 `systemctl status sshd`         |

systemctl命令的选项很多，我们可以使用systemctl --help进行查看。

#### 查看服务

如果我们不知道系统有哪些服务怎么办？我们只能通过命令去查询所有的服务，然后再去调用，所以第一阶段就是学习怎么去查询服务。

![image-20251215194458250](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215194458250.png)

因为有很多服务，我们可以通过上下方向键来进行浏览。

我们也可以只看正在运行的服务，操作如下：

![image-20251215194625998](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215194625998.png)

有时候我们不知道安装了那些服务，或者我们之后会学习到一些工具的安装，会自带服务，不知道服务名称怎么办？

加入我们要查看ssh的远程连接的服务，我们不知道服务的名称怎么办？可以使用如下操作：

![image-20251215195049158](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215195049158.png)

输出会标注服务的**启用状态**（enabled/disabled/masked）。

我们以`sshd.service`服务为例子，给出一些操作演示命令，操作命令如下：

| 功能                   | 命令示例                                   | 说明                                                         |
| ---------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 查看单个服务状态       | systemctl status sshd.service              | 显示服务是否运行、PID、最近日志、启动状态（可省略 `.service` 后缀） |
| 查看所有活跃服务       | systemctl list-units --type=service        | 仅显示正在运行 / 激活的服务                                  |
| 查看所有服务（含停止） | systemctl list-units --type=service --all  | 包含已停止、失败的服务                                       |
| 查看所有已安装服务     | systemctl list-unit-files --type=service   | 显示所有已安装的服务文件，标注 enabled/disabled/masked 状态  |
| 启动服务               | systemctl start sshd                       | 临时启动服务，重启后失效                                     |
| 停止服务               | systemctl stop sshd                        | 临时停止服务，重启后失效                                     |
| 重启服务               | systemctl restart sshd                     | 停止并重新启动服务（不管当前状态）                           |
| 重载服务配置           | systemctl reload sshd                      | 不停止服务，仅重新加载配置文件（需服务支持，如 nginx、sshd） |
| 重启 + 重载配置        | systemctl reload-or-restart sshd           | 优先重载，若不支持则重启                                     |
| 查看服务是否运行       | systemctl is-active sshd                   | 返回 active/inactive，适合脚本判断                           |
| 设置开机自启           | systemctl enable sshd                      | 永久启用（开机自动启动），需重启生效（或 `daemon-reload`）   |
| 关闭开机自启           | systemctl disable sshd                     | 永久禁用（开机不启动）                                       |
| 查看开机自启状态       | systemctl is-enabled sshd                  | 返回 enabled/disabled/masked，适合脚本判断                   |
| 立即启用 + 开机自启    | systemctl enable --now sshd                | 临时启动 + 永久启用，一步到位                                |
| 立即禁用 + 关闭自启    | systemctl disable --now sshd               | 临时停止 + 永久禁用，一步到位                                |
| 屏蔽服务（禁止启动）   | systemctl mask sshd                        | 彻底禁止启动（包括手动 / 自动），软链接到 `/dev/null`        |
| 解除屏蔽               | systemctl unmask sshd                      | 恢复被屏蔽的服务                                             |
| 查看服务依赖           | systemctl list-dependencies sshd           | 显示该服务依赖的其他单元（正向依赖）                         |
| 查看反向依赖           | systemctl list-dependencies --reverse sshd | 显示依赖该服务的其他单元                                     |
| 查看服务详细信息       | systemctl show sshd                        | 输出服务的所有配置参数（如启动超时、用户、依赖等）           |
| 重置服务失败状态       | systemctl reset-failed sshd                | 若服务启动失败，重置其失败标记（解决 `failed` 状态）         |

#### 设置target

查看默认的target，操作如下：

![image-20251215200647818](./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/image-20251215200647818.png)

其他操作用表格的形式给出，不做过多的演示，我们知道怎么去设置就行主要是环境生产不是很好模拟。

| 功能                    | 命令示例                                | 说明                                                         |
| ----------------------- | --------------------------------------- | ------------------------------------------------------------ |
| 查看当前默认 target     | systemctl get-default                   | 返回如 multi-user.target（命令行）、graphical.target（图形界面） |
| 设置默认 target         | systemctl set-default multi-user.target | 永久设置默认运行级别（重启生效）                             |
| 临时切换 target         | systemctl isolate multi-user.target     | 立即切换到指定 target（不修改默认值），如从图形界面切到命令行 |
| 查看当前运行的 target   | systemctl list-units --type=target      | 显示当前激活的 target                                        |
| 切换到紧急模式          | systemctl isolate emergency.target      | 极端故障修复模式（仅只读挂载根目录）                         |
| 切换到单用户模式        | systemctl isolate rescue.target         | 基础维护模式（可读写根目录，无网络）                         |
| 关机                    | systemctl poweroff                      | 等价于传统 runlevel 0                                        |
| 重启                    | systemctl reboot                        | 等价于传统 runlevel 6                                        |
| 挂起（休眠）            | systemctl suspend                       | 内存数据暂存，低功耗，唤醒快                                 |
| 休眠（挂起 + 磁盘写入） | systemctl hibernate                     | 内存数据写入磁盘，断电不丢失，唤醒慢                         |
| 混合休眠                | systemctl hybrid-sleep                  | 同时挂起 + 休眠，兼顾速度和安全性                            |

#### 其他

这里给出一些其他的操作命令，不做演示了，常用的大致就是这样：

| 功能                  | 命令示例                                    | 说明                                                         |
| --------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 重新加载 systemd 配置 | systemctl daemon-reload                     | 修改服务配置文件（如 `/usr/lib/systemd/system/sshd.service`）后，需执行该命令让 systemd 识别变更 |
| 查看 systemd 状态     | systemctl status                            | 查看 systemd 主进程（PID 1）的状态                           |
| 列出所有 systemd 单元 | systemctl list-units                        | 显示所有类型的单元（service、target、mount 等）              |
| 查看系统启动耗时      | systemd-analyze                             | 显示开机总耗时，及各服务启动耗时                             |
| 查看服务启动耗时排行  | systemd-analyze blame                       | 按耗时从长到短列出服务，定位开机慢的原因                     |
| 生成开机启动流程图    | systemd-analyze plot > boot.svg             | 生成 SVG 格式的启动流程图表，可下载到本地查看                |
| 查看系统版本          | systemctl --version                         |                                                              |
| 查看远程主机服务      | systemctl -H root@192.168.1.100 status sshd | 远程管理其他主机的服务（需开启 SSH 且有权限）                |
| 定时启动服务          | systemctl start sshd --after=5min           | 延迟 5 分钟启动服务（需 systemd 230+ 版本）                  |

### service

`service` 命令是 **Linux 系统中用于管理系统服务** 的核心工具，主要作用是简化对 `/etc/init.d/` 目录下的服务脚本的操作（适用于传统 SysV 初始化系统），也兼容部分 Systemd 系统（通过封装实现）。它的核心是 “统一接口”—— 无需记住服务脚本的完整路径，即可快速启动、停止、重启服务。和systemctl功能类似，兼容性更好，毕竟是原生功能，但是随着Linux的更新迭代systemctl很多时候成了首选，部分Linux发行版甚至不再支持service命令操作了。

```
语法：
service <服务名> <操作指令> [参数]
```

常用的操作指令：

| 指令                        | 作用                              |
| --------------------------- | --------------------------------- |
| start                       | 启动服务                          |
| stop                        | 停止服务                          |
| restart                     | 重启服务                          |
| reload                      | 重新加载配置文件                  |
| status                      | 查看服务运行状态                  |
| enable`/`disable` `/disable | (部分系统支持)设置开机自启 / 关闭 |

例如查看系统所有可管理的服务：

```shell
# 列出 /etc/init.d/ 下所有服务（SysV 系统）
service --status-all

# 或简化版（仅显示服务名）
ls /etc/init.d/
```

部分新的发行版已经不在支持，比如**Fedora 是纯 Systemd 系统，默认不安装 SysV 初始化脚本（/etc/init.d）相关组件**，而 `service` 命令是为传统 SysV 系统设计的，因此在 Fedora 上直接用 `service` 会报错（找不到 `/etc/init.d` 目录）。

管理常见的一些服务，操作如下：

```shell
# 启动网络服务
service network start
# 停止防火墙（CentOS 6）
service iptables stop
# 重启 Nginx 服务
service nginx restart
# 查看 MySQL 运行状态
service mysqld status
```

### 定时任务











## 打赏

如果觉得文章写的还不错，可以给作者一个小小的支持嘛？请我喝杯蜜雪冰城可好？

<img src="./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE.png" alt="微信收款" style="zoom: 50%;" />

<img src="./08%E4%BB%BB%E5%8A%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B.assets/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE.jpg" alt="支付宝收款" style="zoom:50%;" />

---




