"use strict";(self.webpackChunkxxx252525_github_io=self.webpackChunkxxx252525_github_io||[]).push([[4145],{1021:(i,a)=>{a.A=(i,a)=>{const e=i.__vccOpts||i;for(const[i,s]of a)e[i]=s;return e}},6085:(i,a,e)=>{e.r(a),e.d(a,{comp:()=>C,data:()=>z});var s=e(6254);const n=e.p+"assets/img/image-20241008154502344.a3e561c0.png",l=e.p+"assets/img/image-20241008154851225.c4ce77ea.png",t=e.p+"assets/img/image-20241008155117061.e1614985.png",p=e.p+"assets/img/image-20241008155855095.4fabb51e.png",d=e.p+"assets/img/image-20241008160523189.746652a3.png",r=e.p+"assets/img/image-20241008160720880.164aa683.png",g=e.p+"assets/img/image-20241008161000567.cfe3b05b.png",h=e.p+"assets/img/image-20241008161412963.b3dd1086.png",c=e.p+"assets/img/image-20241008161819911.ede068db.png",o=e.p+"assets/img/image-20241008161934157.d065ed66.png",m=e.p+"assets/img/image-20241008162155664.c03b48df.png",u=e.p+"assets/img/image-20241008162655993.7b6f3c9a.png",k=e.p+"assets/img/image-20241008162801287.b36d152c.png",b=e.p+"assets/img/image-20241008163414496.174c2b24.png",f=e.p+"assets/img/image-20241008163556851.db9753d0.png",v=e.p+"assets/img/image-20241008163803036.e5188f2f.png",x=e.p+"assets/img/image-20241008164051663.e8377cc9.png",A=e.p+"assets/img/image-20241008165250676.d9502de3.png",y=e.p+"assets/img/image-20241008165737564.787b1f0d.png",F=e.p+"assets/img/image-20241008170054278.6e7338f7.png",w={},C=(0,e(1021).A)(w,[["render",function(i,a){return(0,s.uX)(),(0,s.CE)("div",null,a[0]||(a[0]=[(0,s.Fv)('<h1 id="_03-查看包名的方式" tabindex="-1"><a class="header-anchor" href="#_03-查看包名的方式"><span>03-查看包名的方式</span></a></h1><h2 id="什么是包" tabindex="-1"><a class="header-anchor" href="#什么是包"><span>什么是包？</span></a></h2><p>像常见的apk、apks、xapk，这些归档格式的压缩包其实就是包，后面会详细讲解包的结构。</p><p>包名就是在Manifest文件中被定义了的名字，而不是xxx.apk，也是不是apk前面的名字，这是可以修改的，真实的包名是Manifest文件中package这个参数的值，这个值就是包名。</p><h2 id="反编译查看清单文件" tabindex="-1"><a class="header-anchor" href="#反编译查看清单文件"><span>反编译查看清单文件</span></a></h2><p>打开jadx或者jeb或者gda，打开apk文件，我拿三个软件都做一例子。</p><h3 id="jadx" tabindex="-1"><a class="header-anchor" href="#jadx"><span>jadx</span></a></h3><p>使用jadx打开apk之后，左边的目录主要会存在三个文件夹，输出、源代码、资源文件，我们要反编译查看包名就需要到资源文件中去看AndroidManifest.txt，这是APK的核心文件，文件中定义了程序的名称、版本、权限、引用的库文件等信息。如图：</p><figure><img src="'+n+'" alt="image-20241008154502344" tabindex="0" loading="lazy"><figcaption>image-20241008154502344</figcaption></figure><p>在文件中<code>package=&quot;cn.trinea.android.developertools&quot;</code>中的cn.trinea.android.developertools就是软件包的包名，而下面那些是相关的Android SDK版本、软件版本、版本名字等相关信息。</p><h3 id="jeb" tabindex="-1"><a class="header-anchor" href="#jeb"><span>JEB</span></a></h3><p>在JEB中我们打开apk包之后，在左边的侧边栏中就可以看到一个Manifest文件，我们点击打开文件就可以看到相关的内容，如下：</p><figure><img src="'+l+'" alt="image-20241008154851225" tabindex="0" loading="lazy"><figcaption>image-20241008154851225</figcaption></figure><h3 id="gda" tabindex="-1"><a class="header-anchor" href="#gda"><span>GDA</span></a></h3><p>进入软件之后打开apk包之后是这样的，一目了然：</p><figure><img src="'+t+'" alt="image-20241008155117061" tabindex="0" loading="lazy"><figcaption>image-20241008155117061</figcaption></figure><p>JDA的体验或许没有其他软件体验号，打开Manifest文件的时候有点卡顿，这一点要注意，非常吃资源，需要你多分配一点内存。</p><figure><img src="'+p+'" alt="image-20241008155855095" tabindex="0" loading="lazy"><figcaption>image-20241008155855095</figcaption></figure><h2 id="通过shell命令获取包名" tabindex="-1"><a class="header-anchor" href="#通过shell命令获取包名"><span>通过shell命令获取包名</span></a></h2><p>除了以上使用反编译的工具可以查看包名，还可以使用shell命令。</p><p><strong>查看包列表</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> list</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> packages</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在进入Android shell之后使用pm list packages命令可以查看所有的软件包。如图：</p><figure><img src="'+d+'" alt="image-20241008160523189" tabindex="0" loading="lazy"><figcaption>image-20241008160523189</figcaption></figure><p>如果逆向在Linux shell或者Windows powershell中去执行该命令，只需要在前面添加一个adb shell即可：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">adb</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> shell</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> list</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> packages</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+r+'" alt="image-20241008160720880" tabindex="0" loading="lazy"><figcaption>image-20241008160720880</figcaption></figure><h3 id="通过进程查看包名" tabindex="-1"><a class="header-anchor" href="#通过进程查看包名"><span>通过进程查看包名</span></a></h3><p>还可以通过进程来查看软件包的包名，使用Linux的shell命令<code>ps</code>就可以查看，例如：</p><figure><img src="'+g+'" alt="image-20241008161000567" tabindex="0" loading="lazy"><figcaption>image-20241008161000567</figcaption></figure><p>在后续的Linux高版本的内核中，移除了直接使用ps查看进程的方式，需要<code>ps -A</code>命令查看：</p><figure><img src="'+h+'" alt="image-20241008161412963" tabindex="0" loading="lazy"><figcaption>image-20241008161412963</figcaption></figure><h3 id="查看app私有目录" tabindex="-1"><a class="header-anchor" href="#查看app私有目录"><span>查看app私有目录</span></a></h3><p>我们可以通过查看app的私有目录的方式来查看包名，我们需要将路径切换到data/data目录下：</p><figure><img src="'+c+'" alt="image-20241008161819911" tabindex="0" loading="lazy"><figcaption>image-20241008161819911</figcaption></figure><p>也可以查看app的安装目录来查看app的包名：</p><figure><img src="'+o+'" alt="image-20241008161934157" tabindex="0" loading="lazy"><figcaption>image-20241008161934157</figcaption></figure><p>这里的app名字是进行了编码的，很明显使用的是Base64进行的编码，我们可以通过工具进行解码：</p><figure><img src="'+m+'" alt="image-20241008162155664" tabindex="0" loading="lazy"><figcaption>image-20241008162155664</figcaption></figure><p>这里显示乱码的原因是错误解码的问题，我们可以通过转码成为16进制：</p><figure><img src="'+u+'" alt="image-20241008162655993" tabindex="0" loading="lazy"><figcaption>image-20241008162655993</figcaption></figure><p>然后再进行16进制解码即可，解码结果如下：</p><figure><img src="'+k+'" alt="image-20241008162801287" tabindex="0" loading="lazy"><figcaption>image-20241008162801287</figcaption></figure><h3 id="输出窗口服务信息" tabindex="-1"><a class="header-anchor" href="#输出窗口服务信息"><span>输出窗口服务信息</span></a></h3><p>我们可以输出当前正在运行的程序服务的信息来获取包名，执行dumpsys window windows命令时，它会列出所有与窗口管理相关的信息，这些信息对于调试应用程序的布局问题、多窗口模式的支持以及其他与UI相关的问题非常有用。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dumpsys</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> window</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> windows</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+b+'" alt="image-20241008163414496" tabindex="0" loading="lazy"><figcaption>image-20241008163414496</figcaption></figure><p>我们可以使用<code>grep</code>命令进行信息的过滤：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dumpsys</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> window</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> windows</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> qq</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+f+'" alt="image-20241008163556851" tabindex="0" loading="lazy"><figcaption>image-20241008163556851</figcaption></figure><p>可以看见我们把QQ的相关信息给过滤了出来。</p><p>如果我们要在Linux或者Windows上面直接操作，我们只需要在前面添加adb shell即可，如果有多个设备，指定一个设备就可以了：</p><figure><img src="'+v+'" alt="image-20241008163803036" tabindex="0" loading="lazy"><figcaption>image-20241008163803036</figcaption></figure><p>如果你用的是Windows操作系统，那么直接吧grep换成findstr就可以了，因为grep命令只能在Linux/Unix环境中去使用，Windows需要使用别的命令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>dumpsys window windows | findstr qq</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+x+'" alt="image-20241008164051663" tabindex="0" loading="lazy"><figcaption>image-20241008164051663</figcaption></figure><h4 id="获取用户交互焦点信息" tabindex="-1"><a class="header-anchor" href="#获取用户交互焦点信息"><span>获取用户交互焦点信息</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Android：</span></span>\n<span class="line"><span>dumpsys window windows | grep mFocusedApp</span></span>\n<span class="line"><span>dumpsys window windows | findstr mFocusedApp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用来找出当前Android设备上获得焦点（即用户正在交互）的应用的信息，如图：</p><figure><img src="'+A+'" alt="image-20241008165250676" tabindex="0" loading="lazy"><figcaption>image-20241008165250676</figcaption></figure><p>由于没有任何进行交互，所以没有信息返回。</p><hr><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Android：\t</span></span>\n<span class="line"><span>dumpsys window windows | grep mCurrentFocus</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Linux：\t\t</span></span>\n<span class="line"><span>adb shell dumpsys window windows | grep mCurrentFocus</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Windows：\t</span></span>\n<span class="line"><span>adb shell dumpsys window windows | findstr mCurrentFocus</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用于显示当前Android设备上当前获得焦点（即用户正在查看或交互）的窗口的信息，例如：</p><figure><img src="'+y+'" alt="image-20241008165737564" tabindex="0" loading="lazy"><figcaption>image-20241008165737564</figcaption></figure><hr><p>目前正在交互的窗口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Android：</span></span>\n<span class="line"><span>dumpsys window | grep mCurrentFocus</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Linux：</span></span>\n<span class="line"><span>adb shell dumpsys window | grep mCurrentFocus </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Windows：</span></span>\n<span class="line"><span>adb shell dumpsys window | findstr mCurrentFocus</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+F+'" alt="image-20241008170054278" tabindex="0" loading="lazy"><figcaption>image-20241008170054278</figcaption></figure><p>这里返回了QQ的焦点信息和QQ的包，最后面的信息是QQ的焦点，前面的绿框是QQ的包名。</p>',70)]))}]]),z=JSON.parse('{"path":"/AndroidReverse/01-Android%E5%9F%BA%E7%A1%80/03-%E8%AE%A4%E8%AF%86%E5%8C%85.html","title":"03-查看包名的方式","lang":"zh-CN","frontmatter":{"icon":"/assets/icon/android.svg","category":["Android逆向"],"contributors":true,"lastUpdated":true,"pageview":true,"isOriginal":true,"description":"03-查看包名的方式 什么是包？ 像常见的apk、apks、xapk，这些归档格式的压缩包其实就是包，后面会详细讲解包的结构。 包名就是在Manifest文件中被定义了的名字，而不是xxx.apk，也是不是apk前面的名字，这是可以修改的，真实的包名是Manifest文件中package这个参数的值，这个值就是包名。 反编译查看清单文件 打开jadx或...","head":[["meta",{"property":"og:url","content":"https://xxx252525.github.io/AndroidReverse/01-Android%E5%9F%BA%E7%A1%80/03-%E8%AE%A4%E8%AF%86%E5%8C%85.html"}],["meta",{"property":"og:site_name","content":"天阁创客的三味书屋"}],["meta",{"property":"og:title","content":"03-查看包名的方式"}],["meta",{"property":"og:description","content":"03-查看包名的方式 什么是包？ 像常见的apk、apks、xapk，这些归档格式的压缩包其实就是包，后面会详细讲解包的结构。 包名就是在Manifest文件中被定义了的名字，而不是xxx.apk，也是不是apk前面的名字，这是可以修改的，真实的包名是Manifest文件中package这个参数的值，这个值就是包名。 反编译查看清单文件 打开jadx或..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-15T05:06:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-15T05:06:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03-查看包名的方式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-15T05:06:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"天阁创客official\\",\\"url\\":\\"https://tiangesec.org.cn\\",\\"email\\":\\"tiangesec@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"什么是包？","slug":"什么是包","link":"#什么是包","children":[]},{"level":2,"title":"反编译查看清单文件","slug":"反编译查看清单文件","link":"#反编译查看清单文件","children":[{"level":3,"title":"jadx","slug":"jadx","link":"#jadx","children":[]},{"level":3,"title":"JEB","slug":"jeb","link":"#jeb","children":[]},{"level":3,"title":"GDA","slug":"gda","link":"#gda","children":[]}]},{"level":2,"title":"通过shell命令获取包名","slug":"通过shell命令获取包名","link":"#通过shell命令获取包名","children":[{"level":3,"title":"通过进程查看包名","slug":"通过进程查看包名","link":"#通过进程查看包名","children":[]},{"level":3,"title":"查看app私有目录","slug":"查看app私有目录","link":"#查看app私有目录","children":[]},{"level":3,"title":"输出窗口服务信息","slug":"输出窗口服务信息","link":"#输出窗口服务信息","children":[]}]}],"git":{"createdTime":1739595979000,"updatedTime":1739595979000,"contributors":[{"name":"xxx252525","username":"xxx252525","email":"1072441436@qq.com","commits":1,"url":"https://github.com/xxx252525"}]},"readingTime":{"minutes":4.75,"words":1424},"filePathRelative":"AndroidReverse/01-Android基础/03-认识包.md","localizedDate":"2025年2月15日","autoDesc":true}')}}]);